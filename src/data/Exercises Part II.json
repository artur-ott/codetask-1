{
  "id": 8,
  "title": "Exercises Part II",
  "chapters": [
    {
      "id": 16,
      "title": "Tuples",
      "tasks": [
        {
          "id": "koan1",
          "tag": "koan-task",
          "data": {
            "description": "Tuples can be created easily",
            "code": "val tuple = (\"apple\", \"dog\")\ntuple should be(__)",
            "mode": "scala",
            "solutions": [
              "(\"apple\", \"dog\")"
            ]
          }
        },
        {
          "id": "koan2",
          "tag": "koan-task",
          "data": {
            "description": "Tuple items may be accessed individually",
            "code": "val tuple = (\"apple\", \"dog\")\nval fruit = tuple._1\nval animal = tuple._2\n\nfruit should be(__)\nanimal should be(__)",
            "mode": "scala",
            "solutions": [
              "\"apple\"",
              "\"dog\""
            ]
          }
        },
        {
          "id": "koan3",
          "tag": "koan-task",
          "data": {
            "description": "Tuples may be of mixed type",
            "code": "val tuple5 = (\"a\", 1, 2.2, new Date(), BigDecimal(5))\n\ntuple5._2 should be(__)\ntuple5._5 should be(__)",
            "mode": "scala",
            "solutions": [
              "1",
              "BigDecimal(5)"
            ]
          }
        },
        {
          "id": "koan4",
          "tag": "koan-task",
          "data": {
            "description": "Tuples items can be swapped on a Tuple 2",
            "code": "val tuple = (\"apple\", 3).swap\ntuple._1 should be(__)\ntuple._2 should be(__)",
            "mode": "scala",
            "solutions": [
              "3",
              "\"apple\""
            ]
          }
        }
      ]
    },
    {
      "id": 17,
      "title": "Options",
      "tasks": [
        {
          "id": "koan1",
          "tag": "koan-task",
          "data": {
            "description": "Option can have one of two values - Some or None",
            "code": "val someValue: Option[String] = Some(\"I am wrapped in something\")\nsomeValue.get should be(__)\n\nval nullValue: Option[String] = None\nnullValue should be(__)",
            "mode": "scala",
            "solutions": [
              "\"I am wrapped in something\"",
              "None"
            ]
          }
        },
        {
          "id": "koan2",
          "tag": "koan-task",
          "data": {
            "description": "Represent null with None because null is a bad idea",
            "code": "val value1 = maybeItWillReturnSomething(true)\nval value2 = maybeItWillReturnSomething(false)\n\nvalue1.get should be(__)\nintercept[java.util.NoSuchElementException] {\n  value2.get\n}",
            "mode": "scala",
            "solutions": [
              "\"Found value\""
            ]
          }
        },
        {
          "id": "koan3",
          "tag": "koan-task",
          "data": {
            "description": "Provide a default value for None",
            "code": "val value1 = maybeItWillReturnSomething(true)\nval value2 = maybeItWillReturnSomething(false)\n\nvalue1 getOrElse \"No value\" should be(__)\nvalue2 getOrElse \"No value\" should be(__)\nvalue2 getOrElse {\n  \"default function\"\n} should be(__)",
            "mode": "scala",
            "solutions": [
              "\"Found value\"",
              "\"No value\"",
              "\"default function\""
            ]
          }
        },
        {
          "id": "koan4",
          "tag": "koan-task",
          "data": {
            "description": "checking whether option has value",
            "code": "val value1 = maybeItWillReturnSomething(true)\nval value2 = maybeItWillReturnSomething(false)\n\nvalue1.isEmpty should be(__)\nvalue2.isEmpty should be(__)",
            "mode": "scala",
            "solutions": [
              "false",
              "true"
            ]
          }
        },
        {
          "id": "koan5",
          "tag": "koan-task",
          "data": {
            "description": "Option can also be used with pattern matching",
            "code": "val someValue: Option[Double] = Some(20.0)\nval value = someValue match {\n  case Some(v) => v\n  case None => 0.0\n}\nvalue should be(__)\nval noValue: Option[Double] = None\nval value1 = noValue match {\n  case Some(v) => v\n  case None => 0.0\n}\nvalue1 should be(__)",
            "mode": "scala",
            "solutions": [
              "20.0",
              "0.0"
            ]
          }
        },
        {
          "id": "koan6",
          "tag": "koan-task",
          "data": {
            "description": "Option is more than just a replacement of null, its also a collection",
            "code": "Some(10) map { _ + 10} should be(__)\nSome(10) filter { _ == 10} should be(__)\nSome(Some(10)) flatMap { _ map { _ + 10}} should be(__)\n\nvar newValue1 = 0\nSome(20) foreach { newValue1 = _}\nnewValue1 should be(__)\n\nvar newValue2 = 0\nNone foreach { newValue2 = _}\nnewValue2 should be(__)",
            "mode": "scala",
            "solutions": [
              "Some(20)",
              "Some(10)",
              "Some(20)",
              "20",
              "0"
            ]
          }
        },
        {
          "id": "koan7",
          "tag": "koan-task",
          "data": {
            "description": "Using Option to avoid if checks for null",
            "code": "//the ugly version\ndef makeFullName(firstName: String, lastName: String) = {\n  if (firstName != null) {\n    if (lastName != null) {\n      firstName + \" \" + lastName\n    } else {\n      null\n    }\n  } else {\n    null\n  }\n}\nmakeFullName(\"Nilanjan\", \"Raychaudhuri\") should be(__)\nmakeFullName(\"Nilanjan\", null) should be(__)\n\n//the pretty version\ndef makeFullNamePrettyVersion(firstName: Option[String], lastName: Option[String]) = {\n  firstName flatMap {\n    fname =>\n      lastName flatMap {\n        lname =>\n          Some(fname + \" \" + lname)\n      }\n  }\n}\nmakeFullNamePrettyVersion(Some(\"Nilanjan\"), Some(\"Raychaudhuri\")) should be(__)\nmakeFullNamePrettyVersion(Some(\"Nilanjan\"), None) should be(__)",
            "mode": "scala",
            "solutions": [
              "\"Nilanjan Raychaudhuri\"",
              "null",
              "Some(\"Nilanjan Raychaudhuri\")",
              "None"
            ]
          }
        },
        {
          "id": "koan8",
          "tag": "koan-task",
          "data": {
            "description": "Using in for comprehension",
            "code": "val values = List(Some(10), Some(20), None, Some(15))\nval newValues = for {\n  someValue <- values\n  value <- someValue\n} yield value\nnewValues should be(__)",
            "mode": "scala",
            "solutions": [
              "List(10, 20, 15)"
            ]
          }
        }
      ]
    },
    {
      "id": 18,
      "title": "Empty Values",
      "tasks": [
        {
          "id": "koan1",
          "tag": "koan-task",
          "data": {
            "description": "None equals None",
            "code": "assert(None === __)",
            "mode": "scala",
            "solutions": [
              "None"
            ]
          }
        },
        {
          "id": "koan2",
          "tag": "koan-task",
          "data": {
            "description": "None should be identical to None",
            "code": "val a = None\nval b = None\nassert(a eq __)",
            "mode": "scala",
            "solutions": [
              "b"
            ]
          }
        },
        {
          "id": "koan3",
          "tag": "koan-task",
          "data": {
            "description": "None can be converted to a String",
            "code": "assert(None.toString === __)",
            "mode": "scala",
            "solutions": [
              "\"None\""
            ]
          }
        },
        {
          "id": "koan4",
          "tag": "koan-task",
          "data": {
            "description": "An empty list can be represented by another nothing value: Nil",
            "code": "assert(List() === __)",
            "mode": "scala",
            "solutions": [
              "Nil"
            ]
          }
        },
        {
          "id": "koan5",
          "tag": "koan-task",
          "data": {
            "description": "None can be converted to an empty list",
            "code": "val a = None\nassert(a.toList === __)",
            "mode": "scala",
            "solutions": [
              "Nil"
            ]
          }
        },
        {
          "id": "koan6",
          "tag": "koan-task",
          "data": {
            "description": "None is considered empty",
            "code": "assert(None.isEmpty === __)",
            "mode": "scala",
            "solutions": [
              "true"
            ]
          }
        },
        {
          "id": "koan7",
          "tag": "koan-task",
          "data": {
            "description": "None can be cast Any, AnyRef or AnyVal",
            "code": "assert(None.asInstanceOf[Any] === __)\nassert(None.asInstanceOf[AnyRef] === __)\nassert(None.asInstanceOf[AnyVal] === __)",
            "mode": "scala",
            "solutions": [
              "None",
              "None",
              "None"
            ]
          }
        },
        {
          "id": "koan8",
          "tag": "koan-task",
          "data": {
            "description": "None cannot be cast to all types of objects",
            "code": "intercept[ClassCastException] {\n  // put the exception you expect to see in place of the blank\n  assert(None.asInstanceOf[String] === __)\n}",
            "mode": "scala",
            "solutions": [
              "false"
            ]
          }
        },
        {
          "id": "koan9",
          "tag": "koan-task",
          "data": {
            "description": "None can be used with Option instead of null references",
            "code": "val optional: Option[String] = None\nassert(optional.isEmpty === __)\nassert(optional === __)",
            "mode": "scala",
            "solutions": [
              "true",
              "None"
            ]
          }
        },
        {
          "id": "koan10",
          "tag": "koan-task",
          "data": {
            "description": "Some is the opposite of None for Option types",
            "code": "val optional: Option[String] = Some(\"Some Value\")\nassert((optional == None) === __, \"Some(value) should not equal None\")\nassert(optional.isEmpty === __, \"Some(value) should not be empty\")",
            "mode": "scala",
            "solutions": [
              "false",
              "false"
            ]
          }
        },
        {
          "id": "koan11",
          "tag": "koan-task",
          "data": {
            "description": "Option.getOrElse can be used to provide a default in the case of None",
            "code": "val optional: Option[String] = Some(\"Some Value\")\nval optional2: Option[String] = None\nassert(optional.getOrElse(\"No Value\") === __, \"Should return the value in the option\")\nassert(optional2.getOrElse(\"No Value\") === __, \"Should return the specified default value\")",
            "mode": "scala",
            "solutions": [
              "\"Some Value\"",
              "\"No Value\""
            ]
          }
        }
      ]
    },
    {
      "id": 19,
      "title": "Sequences and Arrays",
      "tasks": [
        {
          "id": "koan1",
          "tag": "koan-task",
          "data": {
            "description": "A list can be converted to an array",
            "code": "val l = List(1, 2, 3)\nval a = l.toArray\na should equal(__)",
            "mode": "scala",
            "solutions": [
              "Array(1, 2, 3)"
            ]
          }
        },
        {
          "id": "koan2",
          "tag": "koan-task",
          "data": {
            "description": "Any sequence can be converted to a list",
            "code": "val a = Array(1, 2, 3)\nval s = a.toSeq\nval l = s.toList\nl should equal(__)",
            "mode": "scala",
            "solutions": [
              "List(1, 2, 3)"
            ]
          }
        },
        {
          "id": "koan3",
          "tag": "koan-task",
          "data": {
            "description": "You can create a sequence from a for comprehension",
            "code": "val s = for (v <- 1 to 4) yield v\ns.toList should be(__)",
            "mode": "scala",
            "solutions": [
              "List(1, 2, 3, 4)"
            ]
          }
        },
        {
          "id": "koan4",
          "tag": "koan-task",
          "data": {
            "description": "You can create a sequence from a for comprehension with a condition",
            "code": "val s = for (v <- 1 to 10 if v % 3 == 0) yield v\ns.toList should be(__)",
            "mode": "scala",
            "solutions": [
              "List(3, 6, 9)"
            ]
          }
        },
        {
          "id": "koan5",
          "tag": "koan-task",
          "data": {
            "description": "You can filter any sequence based on a predicate",
            "code": "val s = Seq(\"hello\", \"to\", \"you\")\nval filtered = s.filter(_.length > 2)\nfiltered should be(__)",
            "mode": "scala",
            "solutions": [
              "Seq(\"hello\", \"you\")"
            ]
          }
        },
        {
          "id": "koan6",
          "tag": "koan-task",
          "data": {
            "description": "You can also filter Arrays in the same way",
            "code": "val a = Array(\"hello\", \"to\", \"you\", \"again\")\nval filtered = a.filter(_.length > 3)\nfiltered should be(__)",
            "mode": "scala",
            "solutions": [
              "Array(\"hello\", \"again\")"
            ]
          }
        },
        {
          "id": "koan7",
          "tag": "koan-task",
          "data": {
            "description": "You can map values in a sequence through a function",
            "code": "val s = Seq(\"hello\", \"world\")\nval r = s map {\n  _.reverse\n}\n\nr should be(__)",
            "mode": "scala",
            "solutions": [
              "Seq(\"olleh\", \"dlrow\")"
            ]
          }
        }
      ]
    },
    {
      "id": 20,
      "title": "Iterables",
      "tasks": [
        {
          "id": "koan1",
          "tag": "koan-task",
          "data": {
            "description": "Iterable is a trait that has the ability to return an iterator of itself.\n Some known iterators are Sets, Lists, Vectors, Stacks, and Streams. Iterator has two\n important methods:  `hasNext`, which answers whether the iterator has another element\n available. `next` which will return the next element in the iterator.",
            "code": "val list = List(3, 5, 9, 11, 15, 19, 21)\nval it = list.iterator\nif (it.hasNext) {\n  it.next should be(__)\n}",
            "mode": "scala",
            "solutions": [
              "3"
            ]
          }
        },
        {
          "id": "koan2",
          "tag": "koan-task",
          "data": {
            "description": "`grouped` will return an fixed sized Iterable chucks of an Iterable",
            "code": "val list = List(3, 5, 9, 11, 15, 19, 21, 24, 32)\nval it = list grouped 3\nit.next() should be(__)\nit.next() should be(__)\nit.next() should be(__)",
            "mode": "scala",
            "solutions": [
              "List(3, 5, 9)",
              "List(11, 15, 19)",
              "List(21, 24, 32)"
            ]
          }
        },
        {
          "id": "koan3",
          "tag": "koan-task",
          "data": {
            "description": "`sliding` will return an Iterable that shows a sliding window of an Iterable.",
            "code": "val list = List(3, 5, 9, 11, 15, 19, 21, 24, 32)\nval it = list sliding 3\nit.next() should be(__)\nit.next() should be(__)\nit.next() should be(__)",
            "mode": "scala",
            "solutions": [
              "List(3, 5, 9)",
              "List(5, 9, 11)",
              "List(9, 11, 15)"
            ]
          }
        },
        {
          "id": "koan4",
          "tag": "koan-task",
          "data": {
            "description": "`sliding` can take the size of the window as well the size of the step during each\n iteration",
            "code": "val list = List(3, 5, 9, 11, 15, 19, 21, 24, 32)\nval it = list sliding(3, 3)\nit.next() should be(__)\nit.next() should be(__)\nit.next() should be(__)",
            "mode": "scala",
            "solutions": [
              "List(3, 5, 9)",
              "List(11, 15, 19)",
              "List(21, 24, 32)"
            ]
          }
        },
        {
          "id": "koan5",
          "tag": "koan-task",
          "data": {
            "description": "`takeRight` is the opposite of 'take' in Traversable.  It retrieves the last elements\n of an Iterable. ",
            "code": "val list = List(3, 5, 9, 11, 15, 19, 21, 24, 32)\n(list takeRight 3) should be(__)",
            "mode": "scala",
            "solutions": [
              "List(21, 24, 32)"
            ]
          }
        },
        {
          "id": "koan6",
          "tag": "koan-task",
          "data": {
            "description": "`dropRight` will drop the number of elements from the right. ",
            "code": "val list = List(3, 5, 9, 11, 15, 19, 21, 24, 32)\n(list dropRight 3) should be(__)",
            "mode": "scala",
            "solutions": [
              "List(3, 5, 9, 11, 15, 19)"
            ]
          }
        },
        {
          "id": "koan7",
          "tag": "koan-task",
          "data": {
            "description": "`zip` will stitch two iterables into an iterable of pairs of corresponding elements\n  from both iterables. e.g. Iterable(x1, x2, x3) zip Iterable(y1, y2, y3) will\n  return ((x1,y1), (x2, y2), (x3, y3))",
            "code": "val xs = List(3, 5, 9)\nval ys = List(\"Bob\", \"Ann\", \"Stella\")\n(xs zip ys) should be(__)",
            "mode": "scala",
            "solutions": [
              "List((3, \"Bob\"), (5, \"Ann\"), (9, \"Stella\"))"
            ]
          }
        },
        {
          "id": "koan8",
          "tag": "koan-task",
          "data": {
            "description": "if two Iterables aren't the same size, then `zip` will only zip what can only be paired.\n  e.g. Iterable(x1, x2, x3) zip Iterable(y1, y2) will\n  return ((x1,y1), (x2, y2))",
            "code": "val xs = List(3, 5, 9)\nval ys = List(\"Bob\", \"Ann\")\n(xs zip ys) should be(__)",
            "mode": "scala",
            "solutions": [
              "List((3, \"Bob\"), (5, \"Ann\"))"
            ]
          }
        },
        {
          "id": "koan9",
          "tag": "koan-task",
          "data": {
            "description": "if two Iterables aren't the same size, then `zipAll` can provide filters for what it couldn't\n  find a complement for. e.g. Iterable(x1, x2, x3) zipAll (Iterable(y1, y2), x, y) will\n  return ((x1,y1), (x2, y2, y))",
            "code": "val xs = List(3, 5, 9)\nval ys = List(\"Bob\", \"Ann\")\n(xs zipAll(ys, -1, \"?\")) should be(__)",
            "mode": "scala",
            "solutions": [
              "List((3, \"Bob\"), (5, \"Ann\"), (9, \"?\"))"
            ]
          }
        },
        {
          "id": "koan10",
          "tag": "koan-task",
          "data": {
            "description": "`zipWithIndex` will zip an Iterable with it's integer index",
            "code": "val xs = List(\"Manny\", \"Moe\", \"Jack\")\nxs.zipWithIndex should be(__)",
            "mode": "scala",
            "solutions": [
              "List((\"Manny\", 0), (\"Moe\", 1), (\"Jack\", 2))"
            ]
          }
        },
        {
          "id": "koan11",
          "tag": "koan-task",
          "data": {
            "description": "`sameElements` will return true if the two iterables have the same number of elements",
            "code": "val xs = List(\"Manny\", \"Moe\", \"Jack\")\nval ys = List(\"Manny\", \"Moe\", \"Jack\")\n(xs sameElements ys) should be(__)\n\nval xs1 = Set(3, 2, 1, 4, 5, 6, 7)\nval ys1 = Set(7, 2, 1, 4, 5, 6, 3)\n(xs1 sameElements ys1) should be(__)",
            "mode": "scala",
            "solutions": [
              "true",
              "true"
            ]
          }
        }
      ]
    },
    {
      "id": 21,
      "title": "Traversables",
      "tasks": [
        {
          "id": "koan1",
          "tag": "koan-task",
          "data": {
            "description": "Traverables are the superclass of Lists, Arrays, Maps, Sets, Streams, and more.\n   The methods involved can be applied to each other in a different type.  ++ appends\n   two Traversables together.",
            "code": "val set = Set(1, 9, 10, 22)\nval list = List(3, 4, 5, 10)\nval result = set ++ list\nresult.size should be(__)\n\nval result2 = list ++ set\nresult2.size should be(__)",
            "mode": "scala",
            "solutions": [
              "7",
              "8"
            ]
          }
        },
        {
          "id": "koan2",
          "tag": "koan-task",
          "data": {
            "description": "map will apply the given function on all elements of a\n  Traversable and return a new collection of the result.",
            "code": "val set = Set(1, 3, 4, 6)\nval result = set.map(_ * 4)\nresult.last should be(__)",
            "mode": "scala",
            "solutions": [
              "24"
            ]
          }
        },
        {
          "id": "koan3",
          "tag": "koan-task",
          "data": {
            "description": "flatten will smash all child Traversables within a Traversable",
            "code": "val list = List(List(1), List(2, 3, 4), List(5, 6, 7), List(8, 9, 10))\nlist.flatten should be(__)",
            "mode": "scala",
            "solutions": [
              "1 to 10"
            ]
          }
        },
        {
          "id": "koan4",
          "tag": "koan-task",
          "data": {
            "description": "flatMap will not only apply the given function on all elements of a Traversable,\n  but all elements within the elements and flatten the results",
            "code": "val list = List(List(1), List(2, 3, 4), List(5, 6, 7), List(8, 9, 10))\nval result = list.flatMap(_.map(_ * 4))\nresult should be(__)",
            "mode": "scala",
            "solutions": [
              "(1 to 10) map (_ * 4)"
            ]
          }
        },
        {
          "id": "koan5",
          "tag": "koan-task",
          "data": {
            "description": "flatMap of Options will filter out all Nones and Keep the Somes",
            "code": "val list = List(1, 2, 3, 4, 5)\nval result = list.flatMap(it => if (it % 2 == 0) Some(it) else None)\nresult should be(__)",
            "mode": "scala",
            "solutions": [
              "List(2, 4)"
            ]
          }
        },
        {
          "id": "koan6",
          "tag": "koan-task",
          "data": {
            "description": "collect will apply a partial function to all elements of a Traversable\n          and will return a different collection. In this koan, a case fragment is a partial function.",
            "code": "val list = List(4, 6, 7, 8, 9, 13, 14)\nval result = list.collect {\n  case x: Int if (x % 2 == 0) => x * 3\n}\nresult should be(__)",
            "mode": "scala",
            "solutions": [
              "List(12, 18, 24, 42)"
            ]
          }
        },
        {
          "id": "koan7",
          "tag": "koan-task",
          "data": {
            "description": "collect will apply a partial function to all elements of a Traversable\n  and will return a different collection. In this koan, two case fragments are chained to create\n  a more robust result.",
            "code": "val list = List(4, 6, 7, 8, 9, 13, 14)\nval partialFunction1: PartialFunction[Int, Int] = {\n  case x: Int if x % 2 == 0 => x * 3\n}\nval partialFunction2: PartialFunction[Int, Int] = {\n  case y: Int if y % 2 != 0 => y * 4\n}\nval result = list.collect(partialFunction1 orElse partialFunction2)\nresult should be(__)",
            "mode": "scala",
            "solutions": [
              "List(12, 18, 28, 24, 36, 52, 42)"
            ]
          }
        },
        {
          "id": "koan8",
          "tag": "koan-task",
          "data": {
            "description": "foreach will apply a function to all elements of a Traversable, but unlike\n the map function, it will not return anything since the return type is Unit, which\n is like a void return type in Java, C++",
            "code": "val list = List(4, 6, 7, 8, 9, 13, 14)\nlist.foreach(num => println(num * 4))\nlist should be(__)",
            "mode": "scala",
            "solutions": [
              "List(4, 6, 7, 8, 9, 13, 14)"
            ]
          }
        },
        {
          "id": "koan9",
          "tag": "koan-task",
          "data": {
            "description": "toArray will convert any Traversable to an Array, which is a special wrapper around a\n  primitive Java array.",
            "code": "val set = Set(4, 6, 7, 8, 9, 13, 14)\nval result = set.toArray\nresult.isInstanceOf[Array[Int]] should be(__)",
            "mode": "scala",
            "solutions": [
              "true"
            ]
          }
        },
        {
          "id": "koan10",
          "tag": "koan-task",
          "data": {
            "description": "toList will convert any Traversable to a List.",
            "code": "val set = Set(4, 6, 7, 8, 9, 13, 14)\nval result = set.toList\n\nresult.isInstanceOf[List[_]] should be(__)",
            "mode": "scala",
            "solutions": [
              "true"
            ]
          }
        },
        {
          "id": "koan11",
          "tag": "koan-task",
          "data": {
            "description": "toList, as well as other conversion methods like toSet, toArray,\n  will not convert if the collection type is the same.",
            "code": "val list = List(5, 6, 7, 8, 9)\nval result = list.toList\nresult eq list should be(__) //Reminder: eq tests for reference equality",
            "mode": "scala",
            "solutions": [
              "true"
            ]
          }
        },
        {
          "id": "koan12",
          "tag": "koan-task",
          "data": {
            "description": "toIterable will convert any Traversable to an Iterable. This is a base\n  trait for all Scala collections that define an iterator method to step\n  through one-by-one the collection's elements.\n  (see AboutIterable koan).",
            "code": "val set = Set(4, 6, 7, 8, 9, 13, 14)\nval result = set.toIterable\nresult.isInstanceOf[Iterable[_]] should be(__)",
            "mode": "scala",
            "solutions": [
              "true"
            ]
          }
        },
        {
          "id": "koan13",
          "tag": "koan-task",
          "data": {
            "description": "toSeq will convert any Traversable to a Seq which is an ordered Iterable\n  and is the superclass to List, Queues, and Vectors.  Sequences provide\n  a method apply for indexing. Indices range from 0 up the the\n  length of a sequence.",
            "code": "val set = Set(4, 6, 7, 8, 9, 13, 14)\nval result = set.toSeq\nresult.isInstanceOf[Seq[_]] should be(__)",
            "mode": "scala",
            "solutions": [
              "true"
            ]
          }
        },
        {
          "id": "koan14",
          "tag": "koan-task",
          "data": {
            "description": "toIndexedSeq will convert any Traversable to an IndexedSeq which is\n  an indexed sequence used in\n  Vectors and Strings",
            "code": "val set = Set(4, 6, 7, 8, 9, 13, 14)\nval result = set.toIndexedSeq\nresult.isInstanceOf[IndexedSeq[_]] should be(__)",
            "mode": "scala",
            "solutions": [
              "true"
            ]
          }
        },
        {
          "id": "koan15",
          "tag": "koan-task",
          "data": {
            "description": "toStream will convert any Traversable to a Stream which is\n  a lazy lists where elements are evaluated as they\n  are needed.",
            "code": "val list = List(4, 6, 7, 8, 9, 13, 14)\nval result = list.toStream\nresult.isInstanceOf[Stream[_]] should be(__)\n(result take 3) should be(__)",
            "mode": "scala",
            "solutions": [
              "true",
              "List(4, 6, 7)"
            ]
          }
        },
        {
          "id": "koan16",
          "tag": "koan-task",
          "data": {
            "description": "toSet will convert any Traversable to a Set which is\n  a collection of unordered, unique values",
            "code": "val list = List(4, 6, 7, 8, 9, 13, 14)\nval result = list.toSet\nresult.isInstanceOf[Set[_]] should be(__)",
            "mode": "scala",
            "solutions": [
              "true"
            ]
          }
        },
        {
          "id": "koan17",
          "tag": "koan-task",
          "data": {
            "description": "toMap will convert any Traversable to a Map.  How it's\n used, depends on the original collection, if it's a List or Seq,\n it should be of parameterized type Tuple2.",
            "code": "val list = List(\"Phoenix\" -> \"Arizona\", \"Austin\" -> \"Texas\")\nval result = list.toMap\nresult.isInstanceOf[Map[_, _]] should be(__)",
            "mode": "scala",
            "solutions": [
              "true"
            ]
          }
        },
        {
          "id": "koan18",
          "tag": "koan-task",
          "data": {
            "description": "toMap will convert a Set to a Map,\n it should be of parameterized type Tuple2.",
            "code": "val set = Set(\"Phoenix\" -> \"Arizona\", \"Austin\" -> \"Texas\")\nval result = set.toMap\nresult.isInstanceOf[Map[_, _]] should be(__)",
            "mode": "scala",
            "solutions": [
              "true"
            ]
          }
        },
        {
          "id": "koan19",
          "tag": "koan-task",
          "data": {
            "description": "isEmpty is pretty self evident",
            "code": "val map = Map(\"Phoenix\" -> \"Arizona\", \"Austin\" -> \"Texas\")\nmap.isEmpty should be(__)\n\nval set = Set()\nset.isEmpty should be(__)",
            "mode": "scala",
            "solutions": [
              "false",
              "true"
            ]
          }
        },
        {
          "id": "koan20",
          "tag": "koan-task",
          "data": {
            "description": "nonEmpty is pretty self evident too",
            "code": "val map = Map(\"Phoenix\" -> \"Arizona\", \"Austin\" -> \"Texas\")\nmap.nonEmpty should be(__)\n\nval set = Set()\nset.nonEmpty should be(__)",
            "mode": "scala",
            "solutions": [
              "true",
              "false"
            ]
          }
        },
        {
          "id": "koan21",
          "tag": "koan-task",
          "data": {
            "description": "size provides the size of the traversable",
            "code": "val map = Map(\"Phoenix\" -> \"Arizona\", \"Austin\" -> \"Texas\")\nmap.size should be(__)",
            "mode": "scala",
            "solutions": [
              "2"
            ]
          }
        },
        {
          "id": "koan22",
          "tag": "koan-task",
          "data": {
            "description": "hasDefiniteSize will return true if there is traversable that has a\n          finite end, otherwise false",
            "code": "val map = Map(\"Phoenix\" -> \"Arizona\", \"Austin\" -> \"Texas\")\nmap.hasDefiniteSize should be(__)\n\nimport Stream.cons\nval stream = cons(0, cons(1, Stream.empty))\nstream.hasDefiniteSize should be(__)",
            "mode": "scala",
            "solutions": [
              "true",
              "false"
            ]
          }
        },
        {
          "id": "koan23",
          "tag": "koan-task",
          "data": {
            "description": "head will return the first element of an ordered collection, or some random\n element if order is not defined like in a Set or Map",
            "code": "val list = List(10, 19, 45, 1, 22)\nlist.head should be(__)",
            "mode": "scala",
            "solutions": [
              "10"
            ]
          }
        },
        {
          "id": "koan24",
          "tag": "koan-task",
          "data": {
            "description": "headOption will return the first element as an Option of an order collection,\n or some random element if order is not defined.  If a first element\n is not available, then None is returned",
            "code": "val list = List(10, 19, 45, 1, 22)\nlist.headOption should be(__)\n\nval list2 = List()\nlist2.headOption should be(__)",
            "mode": "scala",
            "solutions": [
              "Some(10)",
              "None"
            ]
          }
        },
        {
          "id": "koan25",
          "tag": "koan-task",
          "data": {
            "description": "last will return the last element of an ordered collection, or some random\n element if order is not defined like in a Set or Map",
            "code": "val list = List(10, 19, 45, 1, 22)\nlist.last should be(__)",
            "mode": "scala",
            "solutions": [
              "22"
            ]
          }
        },
        {
          "id": "koan26",
          "tag": "koan-task",
          "data": {
            "description": "lastOption will return the last element as an Option of an order collection,\n or some random element if order is not defined.  If a first element\n is not available, then None is returned",
            "code": "val list = List(10, 19, 45, 1, 22)\nlist.lastOption should be(__)\n\nval list2 = List()\nlist2.lastOption should be(__)",
            "mode": "scala",
            "solutions": [
              "Some(22)",
              "None"
            ]
          }
        },
        {
          "id": "koan27",
          "tag": "koan-task",
          "data": {
            "description": "find will locate the first item that matches a predicate p as Some or None if\n an element is not found",
            "code": "val list = List(10, 19, 45, 1, 22)\nlist.find(_ % 2 != 0) should be(__)\n\nval list2 = List(4, 8, 16)\nlist2.find(_ % 2 != 0) should be(__)",
            "mode": "scala",
            "solutions": [
              "Some(19)",
              "None"
            ]
          }
        },
        {
          "id": "koan28",
          "tag": "koan-task",
          "data": {
            "description": "tail will return the rest of the collection without the head",
            "code": "val list = List(10, 19, 45, 1, 22)\nlist.tail should be(__)",
            "mode": "scala",
            "solutions": [
              "List(19, 45, 1, 22)"
            ]
          }
        },
        {
          "id": "koan29",
          "tag": "koan-task",
          "data": {
            "description": "init will return the rest of the collection without the last",
            "code": "val list = List(10, 19, 45, 1, 22)\nlist.init should be(__)",
            "mode": "scala",
            "solutions": [
              "List(10, 19, 45, 1)"
            ]
          }
        },
        {
          "id": "koan30",
          "tag": "koan-task",
          "data": {
            "description": "Given a `from` index, and a `to` index, slice will return the part of the\n  collection including `from`, and excluding `to`",
            "code": "val list = List(10, 19, 45, 1, 22)\nlist.slice(1, 3) should be(__)",
            "mode": "scala",
            "solutions": [
              "List(19, 45)"
            ]
          }
        },
        {
          "id": "koan31",
          "tag": "koan-task",
          "data": {
            "description": "Take will return the the first number of elements given.",
            "code": "val list = List(10, 19, 45, 1, 22)\nlist.take(3) should be(__)",
            "mode": "scala",
            "solutions": [
              "List(10, 19, 45)"
            ]
          }
        },
        {
          "id": "koan32",
          "tag": "koan-task",
          "data": {
            "description": "Take is used often with Streams, and Streams after all are Traversable",
            "code": "def streamer(v: Int): Stream[Int] = v #:: streamer(v + 1)\nval a = streamer(2)\n(a take 3 toList) should be(__)",
            "mode": "scala",
            "solutions": [
              "List(2, 3, 4)"
            ]
          }
        },
        {
          "id": "koan33",
          "tag": "koan-task",
          "data": {
            "description": "Drop will take the rest of the Traversable except\n  the number of elements given",
            "code": "def streamer(v: Int): Stream[Int] = v #:: streamer(v + 1)\nval a = streamer(2)\n((a drop 6) take 3).toList should be(__)",
            "mode": "scala",
            "solutions": [
              "List(8, 9, 10)"
            ]
          }
        },
        {
          "id": "koan34",
          "tag": "koan-task",
          "data": {
            "description": "takeWhile will continually accumulate elements until a predicate\n  is no longer satisfied.  In this koan, TreeSet is Traversable.\n  TreeSet also is also sorted.",
            "code": "val list = List(87, 44, 5, 4, 200, 10, 39, 100)\nlist.takeWhile(_ < 100) should be(__)",
            "mode": "scala",
            "solutions": [
              "List(87, 44, 5, 4)"
            ]
          }
        },
        {
          "id": "koan35",
          "tag": "koan-task",
          "data": {
            "description": "dropWhile will continually drop elements until a predicate\n  is no longer satisfied.  Again, TreeSet is Traversable.\n  TreeSet also is also sorted.",
            "code": "val list = List(87, 44, 5, 4, 200, 10, 39, 100)\nlist.dropWhile(_ < 100) should be(__)",
            "mode": "scala",
            "solutions": [
              "List(200, 10, 39, 100)"
            ]
          }
        },
        {
          "id": "koan36",
          "tag": "koan-task",
          "data": {
            "description": "filter will take out all elements that don't satisfy a predicate. An\n  Array is also Traversable.",
            "code": "val array = Array(87, 44, 5, 4, 200, 10, 39, 100)\narray.filter(_ < 100) should be(__)",
            "mode": "scala",
            "solutions": [
              "Array(87, 44, 5, 4, 10, 39)"
            ]
          }
        },
        {
          "id": "koan37",
          "tag": "koan-task",
          "data": {
            "description": "filterNot will take out all elements that satisfy a predicate. An\n  Array is also Traversable.",
            "code": "val array = Array(87, 44, 5, 4, 200, 10, 39, 100)\narray.filterNot(_ < 100) should be(__)",
            "mode": "scala",
            "solutions": [
              "Array(200, 100)"
            ]
          }
        },
        {
          "id": "koan38",
          "tag": "koan-task",
          "data": {
            "description": "splitAt will split a Traversable at a position, returning a 2 product\n  Tuple.  Array is Traversable. splitAt is also defined as\n  (xs take n, xs drop n)",
            "code": "val array = Array(87, 44, 5, 4, 200, 10, 39, 100)\nval result = array splitAt 3\nresult._1 should be(__)\nresult._2 should be(__)",
            "mode": "scala",
            "solutions": [
              "Array(87, 44, 5)",
              "Array(4, 200, 10, 39, 100)"
            ]
          }
        },
        {
          "id": "koan39",
          "tag": "koan-task",
          "data": {
            "description": "span will split a Traversable according to predicate, returning\n  a 2 product Tuple.  Array is Traversable, span\n  is also defined as (xs takeWhile p, xs dropWhile p)",
            "code": "val array = Array(87, 44, 5, 4, 200, 10, 39, 100)\nval result = array span (_ < 100)\nresult._1 should be(__)\nresult._2 should be(__)",
            "mode": "scala",
            "solutions": [
              "Array(87, 44, 5, 4)",
              "Array(200, 10, 39, 100)"
            ]
          }
        },
        {
          "id": "koan40",
          "tag": "koan-task",
          "data": {
            "description": "partition will split a Traversable according to predicate, return\n  a 2 product Tuple. The left side are the elements satisfied by\n  the predicate, the right side is not. Array is Traversable,\n  partition is also defined as (xs filter p, xs filterNot p)",
            "code": "val array = Array(87, 44, 5, 4, 200, 10, 39, 100)\nval result = array partition (_ < 100)\nresult._1 should be(__)\nresult._2 should be(__)",
            "mode": "scala",
            "solutions": [
              "Array(87, 44, 5, 4, 10, 39)",
              "Array(200, 100)"
            ]
          }
        },
        {
          "id": "koan41",
          "tag": "koan-task",
          "data": {
            "description": "groupBy will categorize a Traversable according to function, and return\n          a map with the results.  This koan uses Partial Function chaining.  If you are\n          still unfamiliar with PartialFunctions, see AboutPartialFunctions koans.",
            "code": "val array = Array(87, 44, 5, 4, 200, 10, 39, 100)\n\nval oddAndSmallPartial: PartialFunction[Int, String] = {\n  case x: Int if x % 2 != 0 && x < 100 => \"Odd and less than 100\"\n}\n\nval evenAndSmallPartial: PartialFunction[Int, String] = {\n  case x: Int if x != 0 && x % 2 == 0 && x < 100 => \"Even and less than 100\"\n}\n\nval negativePartial: PartialFunction[Int, String] = {\n  case x: Int if x < 0 => \"Negative Number\"\n}\n\nval largePartial: PartialFunction[Int, String] = {\n  case x: Int if x > 99 => \"Large Number\"\n}\n\nval zeroPartial: PartialFunction[Int, String] = {\n  case x: Int if x == 0 => \"Zero\"\n}\n\nval result = array groupBy {\n    oddAndSmallPartial orElse\n    evenAndSmallPartial orElse\n    negativePartial orElse\n    largePartial orElse\n    zeroPartial\n}\n\n(result(\"Even and less than 100\") size) should be(__)\n(result(\"Large Number\") size) should be(__)",
            "mode": "scala",
            "solutions": [
              "3",
              "2"
            ]
          }
        },
        {
          "id": "koan42",
          "tag": "koan-task",
          "data": {
            "description": "forall will determine if a predicate is valid for all members of a\n  Traversable.",
            "code": "val list = List(87, 44, 5, 4, 200, 10, 39, 100)\nval result = list forall (_ < 100)\nresult should be(__)",
            "mode": "scala",
            "solutions": [
              "false"
            ]
          }
        },
        {
          "id": "koan43",
          "tag": "koan-task",
          "data": {
            "description": "`exists` will determine if a predicate\n is valid for some members of a Traversable.",
            "code": "val list = List(87, 44, 5, 4, 200, 10, 39, 100)\nval result = list exists (_ < 100)\nresult should be(__)",
            "mode": "scala",
            "solutions": [
              "true"
            ]
          }
        },
        {
          "id": "koan44",
          "tag": "koan-task",
          "data": {
            "description": "`count` will count the number of elements that satisfy a predicate\n in a Traversable.",
            "code": "val list = List(87, 44, 5, 4, 200, 10, 39, 100)\nval result = list count (_ < 100)\nresult should be(__)",
            "mode": "scala",
            "solutions": [
              "6"
            ]
          }
        },
        {
          "id": "koan45",
          "tag": "koan-task",
          "data": {
            "description": " `/:` or `foldLeft` will combine an operation starting with a seed and combining from the left.  Fold Left\n is defined as (seed /: list), where seed is the initial value.  Once the fold is established, you\n provide a function that takes two arguments.  The first argument is the running total of the operation,\n and the second element is the next element of the list.\n\n Given a Traversable (x1, x2, x3, x4), an initial value of init, an operation op,\n foldLeft is defined as: (((init op x1) op x2) op x3) op x4)",
            "code": "val list = List(5, 4, 3, 2, 1)\nval result = (0 /: list) {\n  (`running total`, `next element`) => `running total` - `next element`\n}\nresult should be(__)\n\nval result2 = list.foldLeft(0) {\n  (`running total`, `next element`) => `running total` - `next element`\n}\nresult2 should be(__)\n\nval result3 = (0 /: list)(_ - _) //Short hand\nresult3 should be(__)\n\nval result4 = list.foldLeft(0)(_ - _)\nresult4 should be(__)\n\n(((((0 - 5) - 4) - 3) - 2) - 1) should be(__)",
            "mode": "scala",
            "solutions": [
              "-15",
              "-15",
              "-15",
              "-15",
              "-15"
            ]
          }
        },
        {
          "id": "koan46",
          "tag": "koan-task",
          "data": {
            "description": " `:\\` or foldRight` will combine an operation starting with a seed and combining from the right.  Fold right\n is defined as (list :\\ seed), where seed is the initial value.  Once the fold is established, you\n provide a function that takes two elements.  The first is the next element of the list, and the\n second element is the running total of the operation.\n\n Given a Traversable (x1, x2, x3, x4), an initial value of init, an operation op,\n foldRight is defined as: x1 op (x2 op (x3 op (x4 op init)))",
            "code": "val list = List(5, 4, 3, 2, 1)\nval result = (list :\\ 0) {\n  (`next element`, `running total`) => `next element` - `running total`\n}\nresult should be(__)\n\nval result2 = (list foldRight 0) {\n  (`next element`, `running total`) => `next element` - `running total`\n}\nresult2 should be(__)\n\nval result3 = (list :\\ 0)(_ - _) //Short hand\nresult3 should be(__)\n\nval result4 = list.foldRight(0)(_ - _)\nresult4 should be(__)\n\n(5 - (4 - (3 - (2 - (1 - 0))))) should be(__)",
            "mode": "scala",
            "solutions": [
              "3",
              "3",
              "3",
              "3",
              "3"
            ]
          }
        },
        {
          "id": "koan47",
          "tag": "koan-task",
          "data": {
            "description": "`reduceLeft` is the similar to foldLeft, except that the seed is the head value",
            "code": "val intList = List(5, 4, 3, 2, 1)\nintList.reduceLeft {\n  _ + _\n} should be(__)\n\nval stringList = List(\"Do\", \"Re\", \"Me\", \"Fa\", \"So\", \"La\", \"Te\", \"Do\")\nstringList.reduceLeft {\n  _ + _\n} should be(__)",
            "mode": "scala",
            "solutions": [
              "15",
              "\"DoReMeFaSoLaTeDo\""
            ]
          }
        },
        {
          "id": "koan48",
          "tag": "koan-task",
          "data": {
            "description": "`reduceRight` is the similar to foldRight, except that the seed is the last value",
            "code": "val intList = List(5, 4, 3, 2, 1)\nintList.reduceRight {\n  _ + _\n} should be(__)\n\nval stringList = List(\"Do\", \"Re\", \"Me\", \"Fa\", \"So\", \"La\", \"Te\", \"Do\")\nstringList.reduceRight {\n  _ + _\n} should be(__)",
            "mode": "scala",
            "solutions": [
              "15",
              "\"DoReMeFaSoLaTeDo\""
            ]
          }
        },
        {
          "id": "koan49",
          "tag": "koan-task",
          "data": {
            "description": "There are some methods that take much of the folding work out by providing basic functionality.\n  `sum` will add all the elements, product will multiply, min would determine the smallest element, and\n  `max` the largest.",
            "code": "val intList = List(5, 4, 3, 2, 1)\nintList.sum should be(__)\nintList.product should be(__)\nintList.max should be(__)\nintList.min should be(__)",
            "mode": "scala",
            "solutions": [
              "15",
              "120",
              "5",
              "1"
            ]
          }
        },
        {
          "id": "koan50",
          "tag": "koan-task",
          "data": {
            "description": "You would choose foldLeft/reduceLeft or foldRight/reduceRight based on your mathematical goal.\n One other reason for deciding is performance.  foldLeft is more performant since it uses\n tail recursion and is optimized. This koan will either work or you will receive a\n StackOverflowError. If you do receive a StackOverflowError, try reducing the MAX_SIZE value.",
            "code": "val MAX_SIZE = 1000000\nval reduceLeftStartTime = new java.util.Date\n(1 to MAX_SIZE) reduceLeft (_ + _)\nval reduceLeftEndTime = new java.util.Date\n\nval reduceRightStartTime = new java.util.Date\n(1 to MAX_SIZE) reduceRight (_ + _)\nval reduceRightEndTime = new java.util.Date\n\nval totalReduceLeftTime = reduceLeftEndTime.getTime - reduceLeftStartTime.getTime\nval totalReduceRightTime = reduceRightEndTime.getTime - reduceRightStartTime.getTime\n\n(totalReduceRightTime > totalReduceLeftTime) should be(__)",
            "mode": "scala",
            "solutions": [
              "true"
            ]
          }
        },
        {
          "id": "koan51",
          "tag": "koan-task",
          "data": {
            "description": "`transpose` will take a traversable of traversables and group them by their position in\n  it's own traversable.  E.g. ((x1, x2),(y1, y2)).transpose = (x1, y1), (x2, y2).\n  or ((x1, x2),(y1, y2),(z1, z2)).transpose = ((x1, y1, z1), (x2, y2, z2), (x3, y3, z3))",
            "code": "val list = List(List(1, 2, 3), List(4, 5, 6), List(7, 8, 9))\nlist.transpose should be(__)\n\nval list2 = List(List(1), List(4))\nlist2.transpose should be(__)",
            "mode": "scala",
            "solutions": [
              "List(List(1, 4, 7), List(2, 5, 8), List(3, 6, 9))",
              "List(List(1, 4))"
            ]
          }
        },
        {
          "id": "koan52",
          "tag": "koan-task",
          "data": {
            "description": "`mkString` will format a Traversable using a given string as the delimiter.",
            "code": "val list = List(1, 2, 3, 4, 5)\nlist.mkString(\",\") should be(__)",
            "mode": "scala",
            "solutions": [
              "\"1,2,3,4,5\""
            ]
          }
        },
        {
          "id": "koan53",
          "tag": "koan-task",
          "data": {
            "description": "`mkString` will also take a beginning and ending string to surround the list.",
            "code": "val list = List(1, 2, 3, 4, 5)\nlist.mkString(\">\", \",\", \"<\") should be(__)",
            "mode": "scala",
            "solutions": [
              "\">1,2,3,4,5<\""
            ]
          }
        },
        {
          "id": "koan54",
          "tag": "koan-task",
          "data": {
            "description": "`addString` will take a StringBuilder to add the contents of list into the builder.",
            "code": "val stringBuilder = new StringBuilder()\nval list = List(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15)\nstringBuilder.append(\"I want all numbers 6-12: \")\nlist.filter(it => it > 5 && it < 13).addString(stringBuilder, \",\")\nstringBuilder.mkString should be(__)",
            "mode": "scala",
            "solutions": [
              "\"I want all numbers 6-12: 6,7,8,9,10,11,12\""
            ]
          }
        },
        {
          "id": "koan55",
          "tag": "koan-task",
          "data": {
            "description": "Traversables can have views which allow you to efficiently do compound work.",
            "code": "val lst = List(1, 2, 3)\nvar history = List[String]()\n\ndef addHistory(s: String) {\n  history = history :+ s\n}\n\nlst.map { x => addHistory(\"Doubling %s\".format(x)); x * 2}.map\n        { x => addHistory(\"Adding 1 to %s\".format(x)); x + 1}\n\nhistory(0) should be(__)\nhistory(1) should be(__)\nhistory(2) should be(__)\nhistory(3) should be(__)\nhistory(4) should be(__)\nhistory(5) should be(__)\n\nhistory = List[String]()\n\nlst.view.map { x => addHistory(\"Doubling %s\".format(x)); x * 2}.map {\n               x => addHistory(\"Adding 1 to %s\".format(x)); x + 1}.force\n\nhistory(0) should be(__)\nhistory(1) should be(__)\nhistory(2) should be(__)\nhistory(3) should be(__)\nhistory(4) should be(__)\nhistory(5) should be(__)",
            "mode": "scala",
            "solutions": [
              "\"Doubling 1\"",
              "\"Doubling 2\"",
              "\"Doubling 3\"",
              "\"Adding 1 to 2\"",
              "\"Adding 1 to 4\"",
              "\"Adding 1 to 6\"",
              "\"Doubling 1\"",
              "\"Adding 1 to 2\"",
              "\"Doubling 2\"",
              "\"Adding 1 to 4\"",
              "\"Doubling 3\"",
              "\"Adding 1 to 6\""
            ]
          }
        },
        {
          "id": "koan56",
          "tag": "koan-task",
          "data": {
            "description": "Views can also accept a `to` and `from` value which takes the subseq and performs your view\n  functions on the subset.",
            "code": "val list = List(1, 2, 3, 4, 5, 6, 7, 8)\nlist.view(3, 6).map(_ + 2).map(_ * 10).force should be(__)",
            "mode": "scala",
            "solutions": [
              "List(60, 70, 80)"
            ]
          }
        }
      ]
    },
    {
      "id": 22,
      "title": "Case Classes",
      "tasks": [
        {
          "id": "koan1",
          "tag": "koan-task",
          "data": {
            "description": "Case classes have an automatic equals method that works",
            "code": "case class Person(first: String, last: String)\n\nval p1 = new Person(\"Fred\", \"Jones\")\nval p2 = new Person(\"Shaggy\", \"Rogers\")\nval p3 = new Person(\"Fred\", \"Jones\")\n\n(p1 == p2) should be(__)\n(p1 == p3) should be(__)\n\n(p1 eq p2) should be(__)\n(p1 eq p3) should be(__) // not identical, merely equal",
            "mode": "scala",
            "solutions": [
              "false",
              "true",
              "false",
              "false"
            ]
          }
        },
        {
          "id": "koan2",
          "tag": "koan-task",
          "data": {
            "description": "Case classes have an automatic hashcode method that works",
            "code": "case class Person(first: String, last: String)\n\nval p1 = new Person(\"Fred\", \"Jones\")\nval p2 = new Person(\"Shaggy\", \"Rogers\")\nval p3 = new Person(\"Fred\", \"Jones\")\n\n(p1.hashCode == p2.hashCode) should be(__)\n(p1.hashCode == p3.hashCode) should be(__)",
            "mode": "scala",
            "solutions": [
              "false",
              "true"
            ]
          }
        },
        {
          "id": "koan3",
          "tag": "koan-task",
          "data": {
            "description": "Case classes have a convenient way they can be created",
            "code": "case class Dog(name: String, breed: String)\n\nval d1 = Dog(\"Scooby\", \"Doberman\")\nval d2 = Dog(\"Rex\", \"Custom\")\nval d3 = new Dog(\"Scooby\", \"Doberman\") // the old way of creating using new\n\n(d1 == d3) should be(__)\n(d1 == d2) should be(__)\n(d2 == d3) should be(__)",
            "mode": "scala",
            "solutions": [
              "true",
              "false",
              "false"
            ]
          }
        },
        {
          "id": "koan4",
          "tag": "koan-task",
          "data": {
            "description": "Case classes have a convenient toString method defined",
            "code": "case class Dog(name: String, breed: String)\nval d1 = Dog(\"Scooby\", \"Doberman\")\nd1.toString should be(__)",
            "mode": "scala",
            "solutions": [
              "\"Dog(Scooby,Doberman)\""
            ]
          }
        },
        {
          "id": "koan5",
          "tag": "koan-task",
          "data": {
            "description": "Case classes have automatic properties",
            "code": "case class Dog(name: String, breed: String)\n\nval d1 = Dog(\"Scooby\", \"Doberman\")\nd1.name should be(__)\nd1.breed should be(__)\n\n// what happens if you uncomment the line below? Why?\n// d1 is immutable (define with val) but also, the default for field name is val so compilation error \"reassignment to val\"\n// d1.name = \"Scooby Doo\"",
            "mode": "scala",
            "solutions": [
              "\"Scooby\"",
              "\"Doberman\""
            ]
          }
        },
        {
          "id": "koan6",
          "tag": "koan-task",
          "data": {
            "description": "Case classes can have mutable properties",
            "code": "case class Dog(var name: String, breed: String) // the field name is specifically marked as mutable with var, now you can rename a dog, but change its breed? nah!\nval d1 = Dog(\"Scooby\", \"Doberman\")\n\nd1.name should be(__)\nd1.breed should be(__)\n\nd1.name = \"Scooby Doo\" // but is it a good idea?\n\nd1.name should be(__)\nd1.breed should be(__)",
            "mode": "scala",
            "solutions": [
              "\"Scooby\"",
              "\"Doberman\"",
              "\"Scooby Doo\"",
              "\"Doberman\""
            ]
          }
        },
        {
          "id": "koan7",
          "tag": "koan-task",
          "data": {
            "description": "Safer alternatives exist for altering case classes",
            "code": "case class Dog(name: String, breed: String) // Doberman\n\nval d1 = Dog(\"Scooby\", \"Doberman\")\n\nval d2 = d1.copy(name = \"Scooby Doo\") // copy the case class but change the name in the copy\n\nd1.name should be(__) // original left alone\nd1.breed should be(__)\n\nd2.name should be(__)\nd2.breed should be(__) // copied from the original",
            "mode": "scala",
            "solutions": [
              "\"Scooby\"",
              "\"Doberman\"",
              "\"Scooby Doo\"",
              "\"Doberman\""
            ]
          }
        },
        {
          "id": "koan8",
          "tag": "koan-task",
          "data": {
            "description": "Case classes have default and named parameters",
            "code": "val p1 = Person(\"Fred\", \"Jones\", 23, \"111-22-3333\")\nval p2 = Person(\"Samantha\", \"Jones\") // note missing age and ssn\nval p3 = Person(last = \"Jones\", first = \"Fred\", ssn = \"111-22-3333\") // note the order can change, and missing age\nval p4 = p3.copy(age = 23)\n\np1.first should be(__)\np1.last should be(__)\np1.age should be(__)\np1.ssn should be(__)\n\np2.first should be(__)\np2.last should be(__)\np2.age should be(__)\np2.ssn should be(__)\n\np3.first should be(__)\np3.last should be(__)\np3.age should be(__)\np3.ssn should be(__)\n\n(p1 == p4) should be(__)",
            "mode": "scala",
            "solutions": [
              "\"Fred\"",
              "\"Jones\"",
              "23",
              "\"111-22-3333\"",
              "\"Samantha\"",
              "\"Jones\"",
              "0",
              "\"\"",
              "\"Fred\"",
              "\"Jones\"",
              "0",
              "\"111-22-3333\"",
              "true"
            ]
          }
        },
        {
          "id": "koan9",
          "tag": "koan-task",
          "data": {
            "description": "Case classes can be disassembled to their constituent parts as a tuple",
            "code": "val p1 = Person(\"Fred\", \"Jones\", 23, \"111-22-3333\")\n\nval parts = Person.unapply(p1).get // this seems weird, but it's critical to other features of Scala\n\nparts._1 should be(__)\nparts._2 should be(__)\nparts._3 should be(__)\nparts._4 should be(__)",
            "mode": "scala",
            "solutions": [
              "\"Fred\"",
              "\"Jones\"",
              "23",
              "\"111-22-3333\""
            ]
          }
        }
      ]
    },
    {
      "id": 23,
      "title": "Pattern Matching",
      "tasks": [
        {
          "id": "koan1",
          "tag": "koan-task",
          "data": {
            "description": "Pattern matching returns something",
            "code": "val stuff = \"blue\"\n\nval myStuff = stuff match {\n  case \"red\" => println(\"RED\"); 1\n  case \"blue\" => println(\"BLUE\"); 2\n  case \"green\" => println(\"GREEN\"); 3\n  case _ => println(stuff); 0 //case _ will trigger if all other cases fail.\n}\n\nmyStuff should be(__)",
            "mode": "scala",
            "solutions": [
              "2"
            ]
          }
        },
        {
          "id": "koan2",
          "tag": "koan-task",
          "data": {
            "description": "Pattern matching can return complex somethings",
            "code": "val stuff = \"blue\"\n\nval myStuff = stuff match {\n  case \"red\" => (255, 0, 0)\n  case \"green\" => (0, 255, 0)\n  case \"blue\" => (0, 0, 255)\n  case _ => println(stuff); 0\n}\n\nmyStuff should be(__)",
            "mode": "scala",
            "solutions": [
              "0, 0, 255"
            ]
          }
        },
        {
          "id": "koan3",
          "tag": "koan-task",
          "data": {
            "description": "Pattern matching can match complex expressions",
            "code": "def goldilocks(expr: Any) = expr match {\n  case (\"porridge\", \"Papa\") => \"Papa eating porridge\"\n  case (\"porridge\", \"Mama\") => \"Mama eating porridge\"\n  case (\"porridge\", \"Baby\") => \"Baby eating porridge\"\n  case _ => \"what?\"\n}\n\ngoldilocks((\"porridge\", \"Mama\")) should be(__)",
            "mode": "scala",
            "solutions": [
              "\"Mama eating porridge\""
            ]
          }
        },
        {
          "id": "koan4",
          "tag": "koan-task",
          "data": {
            "description": "Pattern matching can wildcard parts of expressions",
            "code": "def goldilocks(expr: Any) = expr match {\n  case (\"porridge\", _) => \"eating\"\n  case (\"chair\", \"Mama\") => \"sitting\"\n  case (\"bed\", \"Baby\") => \"sleeping\"\n  case _ => \"what?\"\n}\n\ngoldilocks((\"porridge\", \"Papa\")) should be(__)\ngoldilocks((\"chair\", \"Mama\")) should be(__)",
            "mode": "scala",
            "solutions": [
              "\"eating\"",
              "\"sitting\""
            ]
          }
        },
        {
          "id": "koan5",
          "tag": "koan-task",
          "data": {
            "description": "Pattern matching can substitute parts of expressions",
            "code": "def goldilocks(expr: Any) = expr match {\n  case (\"porridge\", bear) => bear + \" said someone's been eating my porridge\"\n  case (\"chair\", bear) => bear + \" said someone's been sitting in my chair\"\n  case (\"bed\", bear) => bear + \" said someone's been sleeping in my bed\"\n  case _ => \"what?\"\n}\n\ngoldilocks((\"porridge\", \"Papa\")) should be(__)\ngoldilocks((\"chair\", \"Mama\")) should be(__)",
            "mode": "scala",
            "solutions": [
              "\"Papa said someone's been eating my porridge\"",
              "\"Mama said someone's been sitting in my chair\""
            ]
          }
        },
        {
          "id": "koan6",
          "tag": "koan-task",
          "data": {
            "description": "Pattern matching can be done on regular expression groups",
            "code": "val EatingRegularExpression = \"\"\"Eating Alert: bear=([^,]+),\\s+source=(.+)\"\"\".r     //.r turns a String to a regular expression\nval SittingRegularExpression = \"\"\"Sitting Alert: bear=([^,]+),\\s+source=(.+)\"\"\".r\nval SleepingRegularExpression = \"\"\"Sleeping Alert: bear=([^,]+),\\s+source=(.+)\"\"\".r\n\ndef goldilocks(expr: String) = expr match {\n  case (EatingRegularExpression(bear, source)) => \"%s said someone's been eating my %s\".format(bear, source)\n  case (SittingRegularExpression(bear, source)) => \"%s said someone's been sitting on my %s\".format(bear, source)\n  case (SleepingRegularExpression(bear, source)) => \"%s said someone's been sleeping in my %s\".format(bear, source)\n  case _ => \"what?\"\n}\n\ngoldilocks(\"Eating Alert: bear=Papa, source=porridge\") should be(__)\ngoldilocks(\"Sitting Alert: bear=Mama, source=chair\") should be(__)",
            "mode": "scala",
            "solutions": [
              "\"Papa said someone's been eating my porridge\"",
              "\"Mama said someone's been sitting on my chair\""
            ]
          }
        },
        {
          "id": "koan7",
          "tag": "koan-task",
          "data": {
            "description": "A backquote can be used to refer to a stable variable in scope to create a case statement.\n This prevents what is called \\'Variable Shadowing\\'",
            "code": "val foodItem = \"porridge\"\n\ndef goldilocks(expr: Any) = expr match {\n  case (`foodItem`, _) => \"eating\"\n  case (\"chair\", \"Mama\") => \"sitting\"\n  case (\"bed\", \"Baby\") => \"sleeping\"\n  case _ => \"what?\"\n}\n\ngoldilocks((\"porridge\", \"Papa\")) should be(__)\ngoldilocks((\"chair\", \"Mama\")) should be(__)\ngoldilocks((\"porridge\", \"Cousin\")) should be(__)\ngoldilocks((\"beer\", \"Cousin\")) should be(__)",
            "mode": "scala",
            "solutions": [
              "\"eating\"",
              "\"sitting\"",
              "\"eating\"",
              "\"what?\""
            ]
          }
        },
        {
          "id": "koan8",
          "tag": "koan-task",
          "data": {
            "description": "A backquote can be used to refer to a method parameter as a stable variable to create a case statement.",
            "code": "def patternEquals(i: Int, j: Int) = j match {\n  case `i` => true\n  case _ => false\n}\npatternEquals(3, 3) should be(__)\npatternEquals(7, 9) should be(__)\npatternEquals(9, 9) should be(__)",
            "mode": "scala",
            "solutions": [
              "true",
              "false",
              "true"
            ]
          }
        }
      ]
    },
    {
      "id": 24,
      "title": "Classes",
      "tasks": [
        {
          "id": "koan1",
          "tag": "koan-task",
          "data": {
            "description": "val parameters in class definition define getter",
            "code": "val aClass = new ClassWithValParameter(\"name goes here\")\naClass.name should be(__)",
            "mode": "scala",
            "solutions": [
              "\"name goes here\""
            ]
          }
        },
        {
          "id": "koan2",
          "tag": "koan-task",
          "data": {
            "description": "var parameters in class definition define getter and setter",
            "code": "val aClass = new ClassWithVarParameter(\"description goes here\")\naClass.description should be(__)\n\naClass.description = \"new description\"\naClass.description should be(__)",
            "mode": "scala",
            "solutions": [
              "\"description goes here\"",
              "\"new description\""
            ]
          }
        },
        {
          "id": "koan3",
          "tag": "koan-task",
          "data": {
            "description": "fields defined internally are private to class",
            "code": "val aClass = new ClassWithPrivateFields(\"name\")\n\n// NOTE: aClass.name is not accessible",
            "mode": "scala",
            "solutions": []
          }
        }
      ]
    },
    {
      "id": 25,
      "title": "Objects",
      "tasks": [
        {
          "id": "koan1",
          "tag": "koan-task",
          "data": {
            "description": "An object is a singleton. One object -- that's it. This object is a replacement of static in Java,\n and is called upon much in the same way",
            "code": "object Greeting {\n  def english = \"Hi\"\n\n  def espanol = \"Hola\"\n\n  def deutsch = \"Hallo\"\n\n  def magyar = \"Szia\"\n}\n\nGreeting.english should be(__)\nGreeting.espanol should be(__)\nGreeting.deutsch should be(__)\nGreeting.magyar should be(__)",
            "mode": "scala",
            "solutions": [
              "\"Hi\"",
              "\"Hola\"",
              "\"Hallo\"",
              "\"Szia\""
            ]
          }
        },
        {
          "id": "koan2",
          "tag": "koan-task",
          "data": {
            "description": "Here is proof an object is a singleton, and not a static method in a class",
            "code": "object Greeting {\n  def english = \"Hi\"\n\n  def espanol = \"Hola\"\n\n  def deutsch = \"Hallo\"\n\n  def magyar = \"Szia\"\n}\n\nval x = Greeting\nval y = x\n\nx eq y should be(__) //Reminder, eq checks for reference\n\nval z = Greeting\n\nx eq z should be(__)",
            "mode": "scala",
            "solutions": [
              "true",
              "true"
            ]
          }
        },
        {
          "id": "koan3",
          "tag": "koan-task",
          "data": {
            "description": "An object that has the same name as class is called a companion object,\n it is used to contain factories for the class that it complements",
            "code": "class Movie(val name: String, val year: Short)\n\nobject Movie {\n  def academyAwardBestMoviesForYear(x: Short) = {\n    //These are match statement, more powerful than Java switch statements!\n    x match {\n      case 1930 => Some(new Movie(\"All Quiet On the Western Front\", 1930))\n      case 1931 => Some(new Movie(\"Cimarron\", 1931))\n      case 1932 => Some(new Movie(\"Grand Hotel\", 1931))\n      case _ => None\n    }\n  }\n}\n\nMovie.academyAwardBestMoviesForYear(1932).get.name should be(__)",
            "mode": "scala",
            "solutions": [
              "\"Grand Hotel\""
            ]
          }
        },
        {
          "id": "koan4",
          "tag": "koan-task",
          "data": {
            "description": "A companion object stores shared variables and values for every instantiated class to share.\n (See SecretAgent class and companion object above).",
            "code": "val bond = new SecretAgent(\"James Bond\")\nval felix = new SecretAgent(\"Felix Leitner\")\nval jason = new SecretAgent(\"Jason Bourne\")\nval _99 = new SecretAgent(\"99\")\nval max = new SecretAgent(\"Max Smart\")\n\nbond.shoot(800)\nfelix.shoot(200)\njason.shoot(150)\n_99.shoot(150)\nmax.shoot(200)\n\nSecretAgent.bullets should be(__)",
            "mode": "scala",
            "solutions": [
              "1500"
            ]
          }
        },
        {
          "id": "koan5",
          "tag": "koan-task",
          "data": {
            "description": "A companion object can also see private values and variables of the instantiated objects",
            "code": "val clark = new Person(\"Clark Kent\", \"Superman\")\nval peter = new Person(\"Peter Parker\", \"Spiderman\")\nval bruce = new Person(\"Bruce Wayne\", \"Batman\")\nval diana = new Person(\"Diana Prince\", \"Wonder Woman\")\n\nPerson.showMeInnerSecret(clark) should be (__)\nPerson.showMeInnerSecret(peter) should be (__)\nPerson.showMeInnerSecret(bruce) should be (__)\nPerson.showMeInnerSecret(diana) should be (__)",
            "mode": "scala",
            "solutions": [
              "\"Superman\"",
              "\"Spiderman\"",
              "\"Batman\"",
              "\"Wonder Woman\""
            ]
          }
        }
      ]
    },
    {
      "id": 26,
      "title": "Traits",
      "tasks": [
        {
          "id": "koan1",
          "tag": "koan-task",
          "data": {
            "description": "A class uses the extends keyword to mixin a trait if it is the only relationship the class inherits",
            "code": "case class Event(name: String)\n\ntrait EventListener {\n  def listen(event: Event): String\n}\n\nclass MyListener extends EventListener {\n  def listen(event: Event): String = {\n    event match {\n      case Event(\"Moose Stampede\") => \"An unfortunate moose stampede occurred\"\n      case _ => \"Nothing of importance occurred\"\n    }\n  }\n}\n\nval evt = Event(\"Moose Stampede\")\nval myListener = new MyListener\nmyListener.listen(evt) should be (__)",
            "mode": "scala",
            "solutions": [
              "\"An unfortunate moose stampede occurred\""
            ]
          }
        },
        {
          "id": "koan2",
          "tag": "koan-task",
          "data": {
            "description": "A class can only \\'extend\\' from one class or trait, any subsequent extension should use the keyword \\'with\\'",
            "code": "case class Event(name: String)\n\ntrait EventListener {\n  def listen(event: Event): String\n}\n\nclass OurListener\n\nclass MyListener extends OurListener with EventListener {\n  def listen(event: Event) : String = {\n    event match {\n      case Event(\"Woodchuck Stampede\") => \"An unfortunate woodchuck stampede occurred\"\n      case _ => \"Nothing of importance occurred\"\n    }\n  }\n}\n\nval evt = Event(\"Woodchuck Stampede\")\nval myListener = new MyListener\nmyListener.listen(evt) should be (__)",
            "mode": "scala",
            "solutions": [
              "\"An unfortunate woodchuck stampede occurred\""
            ]
          }
        },
        {
          "id": "koan3",
          "tag": "koan-task",
          "data": {
            "description": "Traits are polymorphic. Any type can be referred to by another type if related by extension",
            "code": "case class Event(name: String)\n\ntrait EventListener {\n  def listen(event: Event): String\n}\n\nclass MyListener extends EventListener {\n  def listen(event: Event) : String = {\n    event match {\n      case Event(\"Moose Stampede\") => \"An unfortunate moose stampede occurred\"\n      case _ => \"Nothing of importance occurred\"\n    }\n  }\n}\n\nval myListener = new MyListener\n\nmyListener.isInstanceOf[MyListener] should be(__)\nmyListener.isInstanceOf[EventListener] should be(__)\nmyListener.isInstanceOf[Any] should be(__)\nmyListener.isInstanceOf[AnyRef] should be(__)",
            "mode": "scala",
            "solutions": [
              "true",
              "true",
              "true",
              "true"
            ]
          }
        },
        {
          "id": "koan4",
          "tag": "koan-task",
          "data": {
            "description": "Traits can have concrete implementations that can be mixed into concrete classes with it's own state",
            "code": "trait Logging {\n  var logCache = List[String]()\n\n  def log(value: String) = {\n    logCache = logCache :+ value\n    println(value)\n  }\n}\n\nclass Welder extends Logging {\n  def weld() {\n    log(\"welding pipe\")\n  }\n}\n\nclass Baker extends Logging {\n  def bake() {\n    log(\"baking cake\")\n  }\n}\n\nval welder = new Welder\nwelder.weld()\n\n\nval baker = new Baker\nbaker.bake()\n\nwelder.logCache.size should be(__)\nbaker.logCache.size should be(__)",
            "mode": "scala",
            "solutions": [
              "1",
              "1"
            ]
          }
        },
        {
          "id": "koan5",
          "tag": "koan-task",
          "data": {
            "description": "Traits are instantiated before a classes instantiation",
            "code": "var sb = List[String]()\n\ntrait T1 {\n  sb = sb :+ \"In T1: x=%s\".format(x)// default value of int is 0\n  val x = 1\n  sb = sb :+ \"In T1: x=%s\".format(x)\n}\n\nclass C1 extends T1 {\n  sb = sb :+ \"In C1: y=%s\".format(y)// default value of int is 0\n  val y = 2\n  sb = sb :+ \"In C1: y=%s\".format(y)\n}\n\nsb = sb :+ \"Creating C1\"\nnew C1\nsb = sb :+ \"Created C1\"\n\nsb.mkString(\";\") should be(__)",
            "mode": "scala",
            "solutions": [
              "\"Creating C1;In T1: x=0;In T1: x=1;In C1: y=0;In C1: y=2;Created C1\""
            ]
          }
        },
        {
          "id": "koan6",
          "tag": "koan-task",
          "data": {
            "description": "Traits are instantiated before a classes instantiation from left to right",
            "code": "var sb = List[String]()\n\ntrait T1 {\n  sb = sb :+ \"In T1: x=%s\".format(x)\n  val x = 1\n  sb = sb :+ \"In T1: x=%s\".format(x)\n}\n\ntrait T2 {\n  sb = sb :+ \"In T2: z=%s\".format(z)\n  val z = 1\n  sb = sb :+ \"In T2: z=%s\".format(z)\n}\n\nclass C1 extends T1 with T2 {\n  sb = sb :+ \"In C1: y=%s\".format(y)\n  val y = 2\n  sb = sb :+ \"In C1: y=%s\".format(y)\n}\n\nsb = sb :+ \"Creating C1\"\nnew C1\nsb = sb :+ \"Created C1\"\n\nsb.mkString(\";\") should be(__)",
            "mode": "scala",
            "solutions": [
              "\"Creating C1;In T1: x=0;In T1: x=1;In T2: z=0;In T2: z=1;In C1: y=0;In C1: y=2;Created C1\""
            ]
          }
        }
      ]
    },
    {
      "id": 27,
      "title": "Constructors",
      "tasks": [
        {
          "id": "koan1",
          "tag": "koan-task",
          "data": {
            "description": "Primary constructor specified with a parameter requires that parameter to be passed in",
            "code": "val aboutMe = new AboutConstructorWithAuxiliaryConstructor()\naboutMe.name should be (__)",
            "mode": "scala",
            "solutions": [
              "\"defaultname\""
            ]
          }
        },
        {
          "id": "koan2",
          "tag": "koan-task",
          "data": {
            "description": "Class with no class parameters is called with no arguments",
            "code": "// add parameter to make this fail\nval aboutMe = new AboutClassWithNoClassParameter",
            "mode": "scala",
            "solutions": []
          }
        }
      ]
    },
    {
      "id": 28,
      "title": "Named and Default Arguments",
      "tasks": [
        {
          "id": "koan1",
          "tag": "koan-task",
          "data": {
            "description": "can specify arguments in any order if you use their names",
            "code": "val me = new WithoutClassParameters()\n\n// what happens if you change the order of these parameters (nothing)\nval myColor = me.addColors(green = 0, red = 255, blue = 0)\n\n// for koan, remove the values in the should equal\nmyColor should equal(__)",
            "mode": "scala",
            "solutions": [
              "255, 0, 0"
            ]
          }
        },
        {
          "id": "koan2",
          "tag": "koan-task",
          "data": {
            "description": "can default arguments if you leave them off",
            "code": "val me = new WithoutClassParameters()\nval myColor = me.addColorsWithDefaults(green = 255)\n\nmyColor should equal(__)",
            "mode": "scala",
            "solutions": [
              "0, 255, 0"
            ]
          }
        },
        {
          "id": "koan3",
          "tag": "koan-task",
          "data": {
            "description": "can access class parameters and specify arguments in any order if you use their names",
            "code": "val me = new WithClassParameters(40, 50, 60)\nval myColor = me.addColors(green = 50, red = 60, blue = 40)\n\nmyColor should equal(__)",
            "mode": "scala",
            "solutions": [
              "100, 100, 100"
            ]
          }
        },
        {
          "id": "koan4",
          "tag": "koan-task",
          "data": {
            "description": "can access class parameters and default arguments if you leave them off",
            "code": "val me = new WithClassParameters(10, 20, 30)\nval myColor = me.addColorsWithDefaults(green = 70)\n\nmyColor should equal(__)",
            "mode": "scala",
            "solutions": [
              "10, 90, 30"
            ]
          }
        },
        {
          "id": "koan5",
          "tag": "koan-task",
          "data": {
            "description": "can default class parameters and have default arguments too",
            "code": "val me = new WithClassParametersInClassDefinition()\nval myColor = me.addColorsWithDefaults(green = 70)\n\nmyColor should equal(__)",
            "mode": "scala",
            "solutions": [
              "0, 325, 100"
            ]
          }
        },
        {
          "id": "koan6",
          "tag": "koan-task",
          "data": {
            "description": "default parameters can be functional too",
            "code": "def reduce(a: Int, f: (Int, Int) => Int = (_ + _)): Int = f(a, a)\n\nreduce(5) should equal(__)\nreduce(5, _ * _) should equal(__)",
            "mode": "scala",
            "solutions": [
              "10",
              "25"
            ]
          }
        }
      ]
    },
    {
      "id": 29,
      "title": "Parent Classes",
      "tasks": [
        {
          "id": "koan1",
          "tag": "koan-task",
          "data": {
            "description": "Class hierarchy is linear, a class can only extend from one parent class",
            "code": "class Worker(val firstName: String, val lastName: String) {}\nclass Employee(override val firstName: String, override val lastName: String,\n               val employeeID: Long) extends Worker(firstName, lastName)\n\nval me = new Employee(\"Name\", \"Yourself\", 1233)\nme.firstName should be(__)\nme.lastName should be(__)",
            "mode": "scala",
            "solutions": [
              "\"Name\"",
              "\"Yourself\""
            ]
          }
        },
        {
          "id": "koan2",
          "tag": "koan-task",
          "data": {
            "description": "A class that extends from another is polymorphic",
            "code": "class Worker(val firstName: String, val lastName: String) {}\nclass Employee(override val firstName: String, override val lastName: String,\n               val employeeID: Long) extends Worker(firstName, lastName)\n\nval me = new Employee(\"Name\", \"Yourself\", 1233)\nval worker: Worker = me\n\nworker.firstName should be(__)\nworker.lastName should be(__)",
            "mode": "scala",
            "solutions": [
              "\"Name\"",
              "\"Yourself\""
            ]
          }
        },
        {
          "id": "koan3",
          "tag": "koan-task",
          "data": {
            "description": "An abstract class, as in Java, cannot be instantiated and only inherited",
            "code": "abstract class Worker(val firstName: String, val lastName: String) {}\n\n// if you uncomment this line, if will fail compilation\n//val worker = new Worker // class Worker is abstract; cannot be instantiated",
            "mode": "scala",
            "solutions": []
          }
        },
        {
          "id": "koan4",
          "tag": "koan-task",
          "data": {
            "description": "A class can be placed inside an abstract class just like in java",
            "code": "abstract class Worker(val firstName: String, val lastName: String) {\n  class Assignment(val hours: Long) {\n    // nothing to do here.  Just observe that it compiles\n  }\n}\nclass Employee(override val firstName: String, override val lastName: String,\n               val employeeID: Long) extends Worker(firstName, lastName)\n\nval employee = new Employee(\"Name\", \"Yourself\", 2291)\nval assignment = new employee.Assignment(22)  //using the employee instance's path, create an assignment for it.\nassignment.hours should be (__)",
            "mode": "scala",
            "solutions": [
              "22"
            ]
          }
        }
      ]
    },
    {
      "id": 30,
      "title": "Methods",
      "tasks": [
        {
          "id": "koan1",
          "tag": "koan-task",
          "data": {
            "description": "In scala, methods can be placed inside in methods, this comes useful for\n recursion where accumulator helper methods can be placed inside the outer method",
            "code": "def factorial(i: Int): Int = {\n  def fact(i: Int, accumulator: Int): Int = {\n    if (i <= 1)\n      accumulator\n    else\n      fact(i - 1, i * accumulator)\n  }\n  fact(i, 1)\n}\n\nfactorial(3) should be (__)",
            "mode": "scala",
            "solutions": [
              "6"
            ]
          }
        },
        {
          "id": "koan2",
          "tag": "koan-task",
          "data": {
            "description": "If a method does not of have equal it is considered `Unit` which is analogous to `void` in Java",
            "code": "def foo(x:Int) {\n  (x + 4)\n}\n\nfoo(5) should be (__)",
            "mode": "scala",
            "solutions": [
              "()"
            ]
          }
        },
        {
          "id": "koan3",
          "tag": "koan-task",
          "data": {
            "description": "If you want to have an = on the method you can make the return type `Unit`,\n this also analogous to `void",
            "code": "def foo(x:Int):Unit = {\n  (x + 4)\n}\n\nfoo(3) should be (__)",
            "mode": "scala",
            "solutions": [
              "()"
            ]
          }
        },
        {
          "id": "koan4",
          "tag": "koan-task",
          "data": {
            "description": "Once you have an =, it is understood that there will be a return type and can be inferred",
            "code": "def foo(x:Int) = 3 + 4\nfoo(3).isInstanceOf[Int] should be (__)",
            "mode": "scala",
            "solutions": [
              "true"
            ]
          }
        },
        {
          "id": "koan5",
          "tag": "koan-task",
          "data": {
            "description": "Of course if you wish to be explicit about the return type, you can attach it at the end of the method",
            "code": "def foo(x:Int):Int = 3 + 4\nfoo(3).isInstanceOf[Int] should be (__)",
            "mode": "scala",
            "solutions": [
              "true"
            ]
          }
        },
        {
          "id": "koan6",
          "tag": "koan-task",
          "data": {
            "description": "As an important concept in function programming and in Scala, a method is also a function",
            "code": "def foo(x:Int) = x * 2\nval result = List(1,2,3).map(foo) //map performs a function on each element\nresult should be (__)",
            "mode": "scala",
            "solutions": [
              "List(2,4,6)"
            ]
          }
        }
      ]
    },
    {
      "id": 31,
      "title": "Preconditions",
      "tasks": [
        {
          "id": "koan1",
          "tag": "koan-task",
          "data": {
            "description": "On precondition violation, intercept expects type of exception thrown",
            "code": "intercept[IllegalArgumentException] {\n  val myInstance = new WithParameterRequirement(0)\n}\n\nval myInstance = new WithParameterRequirement(\"\")// does not break as we use the alternate constructor which discard the input and set the value 1 anyway",
            "mode": "scala",
            "solutions": []
          }
        }
      ]
    }
  ]
}
